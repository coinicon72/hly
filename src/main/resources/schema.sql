--create table bom (
--	id bigint not null auto_increment,
--	create_date datetime default now() not null,
--	formula_id bigint,
--	order_id bigint,
--	product_id bigint,
--	primary key (id));
--
--create table bom_item (
--	calc_quantity float not null,
--	quantity float not null,
--	bom_id bigint not null,
--	material_id bigint not null,
--	primary key (bom_id, material_id));
--
--create table client (
--	id bigint not null auto_increment,
--	address varchar(200),
--	comment varchar(255),
--	contact varchar(30),
--	contract_no varchar(50) not null,
--	delivery_address varchar(200),
--	full_name varchar(100),
--	metadata varchar(500),
--	name varchar(50) not null,
--	phone varchar(30),
--	post_code varchar(6),
--	settlement_policy varchar(100),
--	type_id bigint,
--	primary key (id));
--
--create table client_type (
--	id bigint not null auto_increment,
--	name varchar(50) not null,
--	primary key (id));
--
--create table formula (
--	id bigint not null auto_increment,
--	change_log varchar(200),
--	comment varchar(255),
--	create_date datetime not null,
--	metadata varchar(500),
--	revision integer not null,
--	product_id bigint,
--	primary key (id));
--
--create table formula_item (
--	quantity float not null,
--	formula_id bigint not null,
--	material_id bigint not null,
--	primary key (formula_id, material_id));
--
--create table material (
--	id bigint not null auto_increment,
--	code varchar(20),
--	comment varchar(255),
--	metadata varchar(500),
--	name varchar(50) not null,
--	safe_quantity float not null,
-- 	spec varchar(20) null,
--	type_id bigint not null,
--	primary key (id));
--
--create table material_type (
--	id bigint not null auto_increment,
--	name varchar(50) not null,
--	primary key (id));
--
--create table `order` (
--	id bigint not null auto_increment,
--	actual_value float,
--	comment varchar(255),
--	delivery_date datetime not null,
--	metadata varchar(500),
--	no varchar(20) not null,
--	order_date datetime not null,
--	status tinyint default 0 not null,
--	tax bit not null,
--	value float not null,
--	client_id bigint not null,
--	primary key (id));
--
--create table order_item (
--	actual_quantity float,
--	price float not null,
--	quantity float not null,
--	`order_id` bigint not null,
--	product_id bigint not null,
--	primary key (`order_id`, product_id));
--
--create table produce_condition (
--	input_temperature integer not null,
--	main_miller_rpm integer not null,
--	mesh integer not null,
--	mix_time integer not null,
--	output_temperature integer not null,
--	screw_rpm integer not null,
--	second_miller_rpm integer not null,
--	formula_id bigint not null,
--	primary key (formula_id));
--
--create table product (
--	id bigint not null auto_increment,
--	base varchar(50),
--	code varchar(20) not null,
--	color varchar(20),
--	comment varchar(255),
--	metadata varchar(500),
--	primary key (id));
--
--
--alter table client add constraint UK_923db0lpkwf1yl7ff5hnfvt7w unique (contract_no);
--
--alter table formula add constraint uniq_formula_revision unique (product_id, revision);
--
--alter table material add constraint UK_dvc457p6ww41n1b9vs12e9f36 unique (code);
--
--alter table `order` add constraint UK_e8399sgf6y62t04adtfm5e2ia unique (no);
--
--alter table product add constraint UK_h3w5r1mx6d0e5c6um32dgyjej unique (code);
--
--alter table bom add constraint fk_bom_formula_id foreign key (formula_id) references formula (id);
--
--alter table bom add constraint FKpl04bpbc2t75bmdqmhuectmpr foreign key (order_id, product_id) references order_item (`order_id`, product_id);
--
--alter table bom_item add constraint fk_bom_item_bom foreign key (bom_id) references bom (id) ON DELETE CASCADE;
--
--alter table bom_item add constraint fk_bom_material foreign key (material_id) references material (id);
--
--alter table client add constraint fk_client_type foreign key (type_id) references client_type (id);
--
--alter table formula add constraint fk_formula_rev_product foreign key (product_id) references product (id);
--
--alter table formula_item add constraint fk_formula_item_formula foreign key (formula_id) references formula (id) ON DELETE CASCADE;
--
--alter table formula_item add constraint fk_formula_item_material foreign key (material_id) references material (id);
--
--alter table material add constraint fk_material_type foreign key (type_id) references material_type (id);
--
--alter table `order` add constraint fk_client_order foreign key (client_id) references client (id);
--
--alter table order_item add constraint fk_order_item_order foreign key (`order_id`) references `order` (id) ON DELETE CASCADE;
--
--alter table order_item add constraint fk_order_item_product foreign key (product_id) references product (id);
--
--alter table produce_condition add constraint fk_formula_produce_cond foreign key (formula_id) references formula (id) ON DELETE CASCADE;


--CREATE TABLE `repo` (
--  `material_id` bigint(20) NOT NULL,
--  `quantity` float UNSIGNED NOT NULL,
--  `price` float UNSIGNED NOT NULL,
--  PRIMARY KEY (`material_id`),
--  CONSTRAINT `fk_stock_material` FOREIGN KEY (`material_id`) REFERENCES `material` (`id`)
--) COMMENT='库存';
--
--CREATE TABLE `inventory` (
--  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
--  `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
--  `comment` varchar(200) DEFAULT NULL,
--  PRIMARY KEY (`id`)
--) COMMENT='盘点';
--
--CREATE TABLE `repo_history` (
--  `inventory_id` int(10) unsigned NOT NULL,
--  `material_id` bigint(20) NOT NULL,
--  `quantity` float NOT NULL,
--  `price` float NOT NULL,
--  PRIMARY KEY (`inventory_id`,`material_id`),
--  CONSTRAINT `fk_stock_history_inventory` FOREIGN KEY (`inventory_id`) REFERENCES `inventory` (`id`),
--  CONSTRAINT `fk_stock_history_material` FOREIGN KEY (`material_id`) REFERENCES `material` (`id`)
--) COMMENT='库存历史';
--
--CREATE TABLE `repo_changing` (
--  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
--  `type` tinyint(4) NOT NULL default 0 COMMENT '1 = in-stock, 入库\n-1 = out-stock, 出库\n0 = inventory, 盘点',
--  `status` tinyint(4) NOT NULL default 0 COMMENT '0 = init; 1 = submitted; 2 = executed; -1 = rejected',
--  `create_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
--  `apply_date` timestamp NULL,
--  `applicant` varchar(30) NOT NULL,
--  `application` varchar(200) null default null,
--  `department` varchar(50) null DEFAULT NULL,
--  `amount` float NULL,
--  `keeper` varchar(30) NULL,
--  `execute_date` timestamp null,
--  `comment` varchar(200) default null,
--  PRIMARY KEY (`id`)
--) COMMENT='库存变化';
--
--CREATE TABLE `stock_changing_item` (
--  `stock_changing_id` int(10) unsigned NOT NULL,
--  `material_id` bigint(20) NOT NULL,
--  `quantity` float unsigned NOT NULL,
--  `price` float UNSIGNED NOT NULL,
--  PRIMARY KEY (`stock_changing_id`, `material_id`),
--  CONSTRAINT `fk_stock_changing_item_stock_changing` FOREIGN KEY (`stock_changing_id`) REFERENCES `stock_changing` (`id`),
--  CONSTRAINT `fk_stock_changing_material` FOREIGN KEY (`material_id`) REFERENCES `material` (`id`)
--) COMMENT='库存变化条目';



--DELIMITER $$
--CREATE PROCEDURE `preview_stock_in_changing`(id int)
--BEGIN
--
--select *,
--	current_quantity * current_price as ct,
--	round(in_quantity * in_price, 2) as nt,
--	round(current_quantity + in_quantity, 3) as new_quantity,
--	round((current_quantity * current_price + in_quantity * in_price) / (current_quantity + in_quantity), 2) as new_price
--from (
--select ci.material_id,
--ifnull(repo.quantity, 0) current_quantity, ifnull(repo.price, 0) current_price,
--ci.quantity in_quantity, ci.price in_price
--from repo_changing_item ci
--	join repo_changing c on ci.repo_changing_id = c.id
--    left join repo on repo.material_id = ci.material_id
--where c.type=1 and c.status=1 and ci.repo_changing_id = id
--) tmp;
--
--END$$
--DELIMITER ;


--DELIMITER $$
--CREATE PROCEDURE `preview_stock_out_changing`(cid int)
--BEGIN
--
--select ci.material_id,
--	ifnull(repo.quantity, 0) quantity,
--	ci.quantity require_quantity,
--    ifnull(repo.quantity >= ci.quantity, 0) fulfilled
--from repo_changing_item ci
--	join repo_changing c on ci.repo_changing_id = c.id
--	left join repo on repo.material_id = ci.material_id
--where c.type=-1 and c.status=1
--and ci.repo_changing_id = cid
--;
--
--END$$
--DELIMITER ;


-- DELIMITER $$
-- CREATE PROCEDURE `apply_stock_in_changing`(cid int, executor varchar(30), cmt varchar(200))
-- BEGIN

--     DECLARE EXIT HANDLER FOR SQLEXCEPTION 
--         BEGIN
--             ROLLBACK;
--            resignal;
--         END;

--     START TRANSACTION;

--         insert into repo (material_id, quantity, price) 
--         select * from (
--             select ci.material_id mid, 
--             ci.quantity nq, ci.price np 
--             from repo_changing_item ci join repo_changing c on ci.repo_changing_id = c.id where c.type = 1 and c.status=1 and ci.repo_changing_id = cid) si
--         ON DUPLICATE KEY UPDATE price = round((np * nq + repo.quantity * price) / (repo.quantity + nq), 2), quantity = round(repo.quantity + nq, 3)
--         ;

--         update repo_changing set status=2, execute_date=now(), keeper=executor, comment=cmt where id=cid;

--     COMMIT;

-- END$$
-- DELIMITER ;


--DELIMITER $$
--CREATE DEFINER=`root`@`localhost` PROCEDURE `apply_stock_out_changing`(cid int, executor varchar(30), cmt varchar(200))
--BEGIN
--	declare res, count, err int default 0;
--	DECLARE done int DEFAULT FALSE;
--
--	declare c cursor for select fulfilled, count(*) from (
--select ci.material_id,
--	ifnull(repo.quantity, 0) quantity,
--	ci.quantity require_quantity,
--    ifnull(repo.quantity >= ci.quantity, 0) fulfilled
--from repo_changing_item ci
--	join repo_changing c on ci.repo_changing_id = c.id
--	left join repo on repo.material_id = ci.material_id
--where c.type=-1 and c.status=1
--and ci.repo_changing_id = 10
--) t group by fulfilled -- where fulfilled is false
--;
--
--	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
--
--    DECLARE EXIT HANDLER FOR SQLEXCEPTION
--        BEGIN
--            ROLLBACK;
--            resignal;
--        END;
--
--	open c;
--  read_loop: LOOP
--    FETCH c INTO res, count;
--
--    IF done THEN
--      LEAVE read_loop;
--    END IF;
--
--    if res = 1 and count = 0 then
--		set err = 1;
--        LEAVE read_loop;
--	elseif res = 0 and count > 0 then
--		set err = 2;
--        LEAVE read_loop;
--	end if;
--
--  END LOOP;
--
--  CLOSE c;
--
--  if err = 1 then
--		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'invalid changing id';
--  elseif err = 2 then
--		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'cannot fulfill all item(s)';
--	end if;
--
--    -- do it
--    START TRANSACTION;
--
--	update repo r, repo_changing c, repo_changing_item ci
--	set r.quantity = r.quantity - ci.quantity, ci.price = r.price, c.execute_date = now(), c.status = 2, c.keeper = executor, c.comment = cmt
--	where ci.repo_changing_id = c.id and ci.material_id = r.material_id and c.type=-1 and c.status=1 and c.id = cid;
--
--    COMMIT;
--
--END$$
--DELIMITER ;



select 1;
